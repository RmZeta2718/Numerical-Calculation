## **华东师范大学计算机科学与技术系上机实践报告**

| 课程名称：数值计算                 | 年级：18级        | 上机实践成绩：     |
| ---------------------------------- | ----------------- | ------------------ |
| 指导教师：谢瑾奎                   | 姓名：汪杰        | 上机实践日期：12.9 |
| 上机实践名称：解线性方程组的迭代法 | 学号：10185102223 | 上机实践编号：No.4 |

------

### 一、实验目的

1. 通过上机计算体会迭代法求解线性方程组的特点，并能和消去法比较；
2. 运用所学的迭代法算法，解决各类线性方程组，编出算法程序；
3. 体会上机计算时，终止步骤 $\left\Vert x^{(k+1)}-x^{(k)} \right\Vert_\infty<\varepsilon$ 或 $k>$（给的迭代次数），对迭代法敛散性的意义；
4. 体会初始解 $x^{(0)}$ ，松弛因子的选取，对计算结果的影响。



### 二、使用环境

QT5.15.1，32位编译器



### 三、内容与设计思想

#### 继承以往实验代码

1. 沿用了上次实验打造的 **Matrix** 类。
   - 有了这个类，实现很多东西都会非常方便，对于Jacobi迭代法，甚至可以直接用矩阵运算实现。
   - 在原有实现的基础上，实现一些和本实验有关的函数，如：
     - 矩阵的无穷范数，2-范数
     - 由 vector 生成对角矩阵，生成向量
2. 沿用上次实验中的UI界面矩阵输入功能，提供用户友好的输入方式和全套错误检测。
3. 沿用以往实验中的画图模块，提供可交互的函数图像显示。
4. 沿用上次实验（直接法解线性方程组）的输入样例。

#### Jacobi迭代法

$$
B=I-D^{-1}A\\
g=D^{-1}b\\
x^{(k+1)}=Bx^{(k)}+g
$$

根据上述原理，基于 **Matrix** 类的矩阵乘法重载，实现起来十分方便（仅包含主要逻辑）：

```c++
repo (epoch, 0, max_iter) {
    x1 = x2;
    x2 = B * x1 + g;
    norm = (x1 - x2).norm_inf();
    if (norm < eps)
        break;
}
```

时间复杂度分析：

- 矩阵乘法为 $O(n^2)$ 
- 加法为 $O(n)$ 
- 设迭代次数为 $m$ ，则总复杂度 $O((n^2+n)\cdot m)=O(n^2m)$ 。

若收敛所需的迭代次数与矩阵规模相当，那么使用迭代法将会得不偿失。（直接法的复杂度为 $O(n^3)$ ）

可见，迭代法的性能很大程度上取决于收敛速度。

#### Gauss-Seidel迭代法

$$
S=-(D+L)^{-1}U\\
f=(D+L)^{-1}b\\
x^{(k+1)}=Sx^{(k)}+f
$$

上述公式法由于需要计算逆矩阵，不易实现，故实现时直接模拟具体计算过程。

在Jacobi迭代的基础上，利用已经计算出的数据，提高计算精度与收敛速度。类似于滚动数组的思想。

时间复杂度与Jacobi迭代法是相同的，这里不再赘述。

#### 松弛迭代法（SOR）

在Gauss-Seidel迭代法的基础上，加入松弛系数 $\omega$ 。

复杂度与其他迭代法相同。

#### 算法终止条件

- 收敛的判断是容易实现的： $\left\Vert x^{(k+1)}-x^{(k)} \right\Vert_\infty<\varepsilon$ 。这里不再赘述。
- 如何判断发散？容易想到的一点是：给算法一个循环的次数限制，超过循环次数上限就退出。但是实际上存在更好地判断方式：
  - 迭代发散意味着 $x$ 的某些分量（的绝对值）会无限增长
  - 计算机存储浮点数的范围是有限的，实际上，根据 IEEE754 ，浮点数运算结果超过最大值时，会得到特殊浮点数 `inf` 。且布尔表达式 `inf==inf` 的值为 `true` 。
  - 所以只要判断运算结果是否等于 `inf` 就能知道迭代是否发散。
  - 且从实践结果来看，通常几百次迭代就会发散（因为迭代发散通常呈现指数增长）。因此，通过这种办法，比规定循环次数上限（如 $10^5$ ），效率高得多。
- 但是，算法具有有穷性。不能无限计算下去。如果收敛或发散的速度十分缓慢，亦或是其他特殊情况（见后文），导致算法长时间运行或死循环，那么这就不是一个合格的算法。
  - 所以在实现时依然保留了最大循环次数限制。
- 根据我在其他地方学到的知识，迭代的最终归宿可能有如下几种：
  - 收敛（到一个定值）
  - 发散（到无穷）
  - 震荡（在2个或多个值之间循环变化）
    - 数学上也称为发散
  - 混沌
    - 无明显变化规律，在一定范围内随机跳动，且受计算精度影响极大。
- 其中，后两种就有可能导致算法死循环。但是这种现象是否会在该实验（迭代法解线性方程组）中出现呢？
  - 混沌通常在非线性迭代中才会产生，该实验（应该？）是线性的迭代，所以我认为不会产生混沌。

#### 收敛/发散轨迹

- 对于收敛的迭代，我们希望知道收敛的速度如何，以何种轨迹收敛。
  - 因此，让算法输出每一步迭代的 $x$ 向量，以迭代次数作为横坐标，计算出 $\Vert x\Vert_2$ 作为纵坐标，绘制折线图。
- 对于发散的迭代，我们也希望知道发散的速度有多快。
  - 根据理论可知，发散时，通常 $\Vert x\Vert_2$ 会呈现指数增长。若还是按照线性坐标系画图，图像表现力不够。
  - 于是考虑使用对数坐标系。这样，图像就会大致呈一条直线。通过其斜率就能知道发散的速度。
- 表现形式上：数据点呈现为黑点，并把点连成折线（蓝色）。
  - 之前的实验已经实现了插值方法，但是我认为这里没有必要进行插值。因为中间的插值点是无意义的。连线只是为了更好地看到变化趋势，只有数据点（黑点）是有意义的。
  - 当数据点较多时，密密麻麻的黑点挤在一起，基本连成了线，不太美观，且此时显示数据点也没有观测价值了。因此考虑动态显示数据点。只有点的数量少于一个给定的阈值时才显示。

#### 算法有效性检测

在算法给出计算结果后，正向地检测结果的正确性，即计算 $Ax$ 并与 $b$ 比较，基于矩阵类，可以方便地实现：

```c++
bool LinearSolveIter::check(const Matrix &A, const Array &x, const Array &b, mreal eps) {
    Assert(A, b);
    Assert(A, x);
    Array diff = A * x - b;
    eps = eps <= 0 ? checker_eps : eps;
    return diff.norm_inf() < eps;
}
```

#### 代码封装

所有与迭代法解线性方程组有关的函数都封装在命名空间 **LinearSolveIter** 内。

### 四、实验结果

#### Jacobi迭代法与Gauss-Seidel迭代法比较

注：下面的图像都在精度要求 $\varepsilon=10^{-6}$ 的情况下计算得到。

对于样例1：

Jacobi迭代法在迭代150次后， $\Vert x\Vert_2$ 超过 $10^{100}$ 。

![image-20201210095754741](../模板.assets/image-20201210095754741.png)

而Gauss-Seidel迭代法在80次迭代后就达到 $10^{100}$ 。

![image-20201210095705498](../模板.assets/image-20201210095705498.png)

此外，放大来看，Jacobi迭代法是不稳定的（局部有微小抖动），而Gauss-Seidel迭代法即使放大后也是比较直的。

对于样例2：

Jacobi迭代法是发散的，而Gauss-Seidel迭代法可以在2500次迭代后收敛。

![image-20201210100159186](../模板.assets/image-20201210100159186.png)

对于样例3：

Jacobi方法收敛曲线如下，迭代20次后收敛：

![image-20201210100343753](../模板.assets/image-20201210100343753.png)

Gauss-Seidel迭代法收敛曲线如下，迭代11次后收敛：

![image-20201210100415692](../模板.assets/image-20201210100415692.png)

综上，可以总结出如下规律：

- 收敛速度上，通常Gauss-Seidel迭代法比Jacobi迭代法更快
- 稳定性上，也同样更优（样例1，Jacobi存在抖动）
- 即使是发散的情况，Gauss-Seidel迭代法也比Jacobi迭代法发散地更快

####  $\varepsilon$ 对收敛速度的影响

是显然的， $\varepsilon$ 越大，收敛速度越快，精度越低。

####  $\omega$ 对SOR方法的影响

注：下面的图像都在精度要求 $\varepsilon=10^{-6}$ 的情况下计算得到。

对于样例2：

迭代次数随 $\omega$ 先下降在上升，通过手动三分，得到 $\omega=1.862$ 时，迭代次数最少，约为 $130$ 次。

相比 $\omega=1$ （退化为Gauss-Seidel迭代法）时的 $2500$ 次迭代，有显著提升。

但是迭代次数依然远超矩阵规模。所以较直接法而言不占优势。不知道在矩阵规模较大时，迭代次数是否能维持这个水平。

![image-20201210120235836](../模板.assets/image-20201210120235836.png)

对于样例3：

变化规律相同， $\omega=1.05$ 时，迭代次数为 $10$ 次，最少。

#### SOR有趣结果选记

对样例2，取 $\omega=1.99$ ，收敛曲线如下：

![image-20201210123155510](../模板.assets/image-20201210123155510.png)

出现了类似于阻尼振荡的曲线。且随着 $\omega$ 不断接近 $2$ ，阻尼看上去越来越小，直到 $\omega=2$ 时：

![image-20201210123308618](../模板.assets/image-20201210123308618.png)

图像占满了整个屏幕，如果放大看：

![image-20201210123549768](../模板.assets/image-20201210123549768.png)

能看到清晰的正弦波。这说明阻尼已经降为0了。于是就能理解，为什么 $\omega$ 的有效范围是 $0<\omega<2$ 。

对于样例3，还有更加有趣的现象（把 $b$ 改成全 $1$ 以使图像更有规律）：

![image-20201210123727273](../模板.assets/image-20201210123727273.png)

明显看到，此时的震荡不是简单正弦波，看上去是一个个的小波。这是多个不同频率的正弦波叠加的效果。且整体上同样呈现出指数衰减的阻尼振荡。

限于数学能力，我没有办法进一步分析这些现象的成因。



### 五、调试过程

一个小问题的调试历程记录：

1. 起因
   - 我采用了第三方库 QCustomPlot 来画图，程序写到一半，发现该第三方库版本太低，需要升级，才能支持对数坐标系。
   - 该库的导入方式是通过源代码导入的，即直接把库的所有源代码（qcustomplot.[cpp|h]）放在工程目录下。所以我下载了新的源代码文件，直接覆盖了原有文件。
2. 报错与调试
   - 覆盖之后，重新编译运行工程，链接器报错，提示找不到某些函数，但实际上这些函数我都能直接在源代码中找到对应的实现。
   - 甚至，该第三方库中的一些基本功能都无法使用了，原本正确的代码现在也无法通过编译。
   - 我的第一反应是源代码文件有问题。重新换了一个版本，但问题依然存在。（官方开放下载的源代码不应该有问题）
   - 于是我尝试建立一个新项目，把所有代码移植到新的工程中，成功运行。这说明代码完全没有问题。
3. 原因分析
   - QT项目的编译（或者绝大部分大型项目的编译）都采用部分编译的方式，若源文件没有改动，就不会重新编译这个文件。
   - 我将新的 QCustomPlot 覆盖原有文件时，QT没有检测到该文件的修改，导致新的库文件没有重新编译。所以导致各种奇怪问题。
   - 所以解决方案是：清理（Clean）已经编译的文件，再编译（Build）；或直接 ReBuild



### 六、总结

1. 成功实现各种迭代法。
2. 分析比较了不同迭代法的区别。
3. 吸取调试经验，希望以后能更熟练的甄别这种问题。
4. 探索了用户友好的UI界面设计。
5. 没有探索矩阵规模较大时的算法性能。算法是支持大规模矩阵的（动态分配内存），但是我没有去造数据，若以后有机会可以尝试。




### 七、附录

见工程源文件
